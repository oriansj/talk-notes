*- org -*-
bootstrappable.org project

* What?
A full source bootstrapping for all free software programs
(starting with GuixSD)

* Why?
``recipe for yoghurt: add yoghurt to milk''

** Trust
Due to the activities of nation states in regards to compromising critical
infrastructure and undermining critical freedoms (including software), we don't
know if we can even trust our compilers.

** Reproducibility
We can't collaborate to verify if we are running the same software if our build
processes don't produce identical results.

** Responsibility
We need to stop ignoring the problem and as a community work to fullfill our
responsibilities to our community and promote the trust and good will that made
our communties places we wanted to become members of.

* What?
Producing from the smallest possible source, create the foundation upon which we
depend in a clean bootstrapping function that is auditable and stable.

** Stage0
A universal core bootstrap that produces identical results across arbitrary
hardware and software foundations.
https://savannah.nongnu.org/projects/stage0

*** knight-vm
Using a hardware specification that was implemented back in the 1970s in TTL and
reduced down to the essentials, this sub 32KB reference written in trivial C (to
allow easy manual porting to assembly) is all that needs to be built on any
hardware platform to allow a full bootstrap to occur.

This enables a universal bootstrap on entirely alien hardware (SPARC, PowerPC,
MIPS, RISCV, ARM, x86, z80, 6502, VAX, PDP-10, etc) running arbitrary software
(Linux, Windows, OSX, DOS, CPM, ITS, etc) to exactly reproduce exact bootstrap
binaries from source in moderately high level languages (lisp and FORTH).

If you can write a compatible, every step will produce IDENTICAL results.
This lowers the floor for bootstrapping down to the level of difficulty which
can be achieved within a couple weeks of work.

An example is being built as a part of mescc-tools

*** Stage0 steps
- hex0 monitor (280bytes) ensures you don't need a text editor or any other
software period. Trivial to make by hand (toggling in bytes if you want) or
using a trivial program of your own written in any language you desire.

- hex0 assembler (260 bytes) Only supports line comments (# and ;) [Could be
smaller and if you trust your text editor, you can use this as the bootstrap
instead of the hex monitor]

- hex1 assembler (488 bytes) written in hex0 and provides single char labels and
relative displacements only (16bit for knight-vm, 32bit for amd64)

- hex2 assembler (1036 bytes) written in hex1 and provides long labels, adds
absolute addresses and the missing set (8bit relative, 16bit absolute and 32bit
absolute)

- M0 macro assembler (1792 bytes) written in hex2 and now allows arbitrary
definitions (like DEFINE ADD 05000 or DEFINE ADDI32_to_RAX 4805) and then use
those definitions to write programs (thus it can support both knight, x86 and
arm assembly)

- Stage0 FORTH (4008 bytes) written in M0 macro assembly and extends itself in
its own FORTH Primitives and has a slowly growing initial library (approaching
GFORTH parity thanks to reepca)

- Stage0 Lisp (7984 bytes [and slowly growing]) written in M0 macro assembly.
Supports all of the LISP primitives defined in McCarthy's 1960 paper [Turns out
he missed many essential things] with some modern improvements like Lexical
scope, let expressions and raw string support.

*** Stage0 future
- Lisp compiler written in Stage0 Lisp or FORTH that targets multiple platforms.
- Platform specific ports of M1 and hex2 written in Stage0 Lisp
- VHDL Knight-vm on FPGA
- Knight on TTL with manually punched paper tape (Game over Trusting trust
attack)

*** helping
- Simply verify our sha256sum'd steps produce identical binaries on your weird
shit (git clone 'https://git.savannah.nongnu.org/git/stage0.git' && cd stage0 &&
make && make test
- Hack new functionality in Stage0 Lisp or FORTH
- Find/report bugs
- Audit stage0
- Create programs that make bootstrapping easier

** mescc-tools
Bridging the gap today between stage0 and mes, while providing an example path
to bootstrapping the stage0 virtual machine starting with a small hex assembler.
https://github.com/oriansj/mescc-tools

*** exec_enable
The most essential program for Linux/ELF binaries as without setting the execute
bit, your binaries can't run. Weighing in at 235bytes with the ELF header, this
trivial program ends up quite essential.
Currently prototyped in C, hand converted to M1 macro assembly and waiting on
manual conversion to commented hex0.

*** hex0
The other half of the essential pair required for bootstrapping on AMD64/ELF.
Weighing in at 303bytes with the ELF header, this trivial program is critical to
making all of the later steps.
Currently prototyped in C, hand converted to M1 macro assembly and hand
converted into commented hex0.

*** hex1
Building off of the functionality of hex0 and exec_enable, we extend our hex to
include single character relative labels. Weighing in at 838bytes with the ELF
header and serving only a single purpose (build hex2)
Currently prototyped in C, hand converted to M1 macro assembly and hand
converted into commented hex1 and hex0 (yes it can bootstrap itself).

*** hex2_linker
The final hex stage needed in any bootstrap project. This adds support for
absolute addressing, long labels, multiple offset sizes, eliminates the need for
execute enable and allows arbitrary base addresses.
Currently prototyped in C, waiting on hand conversion to M1 macro assembly.

*** M0 macro assembler
The most primitive macro assembler you can write in hex.
Currently prototyped in C, waiting on hand conversion to M1 macro assembly.

*** M1 macro assembler
The last macro assembler you will ever need to write. This adds support for
multiple architectures and byte Endianness.
Currently prototyped in C, waiting on hand conversion to M1 macro assembly.
Possibly get gdb and objdump to read M1 binaries properly

*** knight-vm
The stage0 vm which will provide a cross platform way to have universal binaries
and verify bootstrap binaries for alternate hardware platforms as well.
Currently prototyped in C, waiting on hand conversion to M1 macro assembly.

** Mes
A late stage bootstrap core componet that ensures that once you have achieved a
certain minimal floor, that you have a solid path to producing GCC and thus
everything you desire.
https://gitlab.com/janneke/mes

*** mes.c
A scheme interpreter prototyped in C ~1400 Lines that standards at our baseline
target of minimal functionality. If you can build this or provide equivalent
functionality, you are good to go.

*** mescc.scm
Provided the above exists and is functional, we leverage that to provide a C
compiler written in Scheme (uses Nyacc C99 parser in Scheme) that is the core of
this project and is the path to full GCC bootstrapping.
mescc along with mescc-tools are capable of self bootstrapping.

*** mes.M1
This autogenerated program exists as a mechanism to give stage0 time to properly
develop to the level of complexity required to support mescc or a compiler
capable of building mescc directly.

Due to the above issue, although it is the mes.c scheme interpreter in annotated
M1 assembly. Its trust is what is considered minimally good enough.

* How to bootstrap?
0) Hardware specific microbootstrap of stage0 virtual machine (in TTL or
mescc-tools for AMD64/ELF environment)
1) stage0
2) mescc
3) tcc
4) gcc
5) guix bootstrap binaries
*done*

* current status
+ mescc can build tcc but minor bugs still need to be solved prior to tcc can
build itself.
+ stage0 has achieved a full path from hex monitor to compacting garbage
collecting lisp and a rather complete FORTH.
+ mescc-tools is a brutally slow tedious exercise in patience and frustration.
+ active community and an exhustive search of possible existing tools has been
done and continues to reduce the development load

* help
+ programmers to help clear out bugs in mescc to finish the tcc bootstrap
+ help find and eliminate bootstrap-loops: (Nyacc?, mes.M1?, psyntax.pp?)
+ integrate with GuixSD (lots of little easy things to do)
+ report bugs, issues, concerns or recommendations
+ testing and finding issues with our documentation (we are human after all)

* strengths of current plan
+ stage0 vm is platform agnostic and arbitrary implementations in both software
and hardware are encouraged.
+ Every possible port of mescc-tools is buildable by every other possible
mescc-tool port and thus forces any hardware/software trusting trust attack to
compromise all past, present and future hardware platforms, including those that
are made for fun out of TTL logic:
http://cpuville.com/Projects/Original-CPU/Original-CPU-home.html or even those
made out of individual transistors: https://monster6502.com/ or should someone
wish http://web.cecs.pdx.edu/~harry/Relay/ using electromechanical relays.
+ Porting of stage0 and mescc-tools to alternate platforms becomes a
straightforward mechanical exercise.
+ No specific host platform is required until the mescc stage.

* weakness of current plan
+ Initial mescc-tools implementation depends upon a trusted linux binary.
+ Stage0 knight-vm performance is bad and thus makes the entire process slow.
+ On ram contrained systems, the performance gets even worse and requires the
addition of paging functionality.
+ Hardware which doesn't align immediates to 4bit multiples are not supported,
or supportable without a change in the hex2_linker design. (Problem for RISCV)
+ Hardware which doesn't have contiguous immediates that are a multiple of 8bits
are not supported or supportable without a change in the hex2_linker design.
(Problem for RISCV and ARM)
+ Requires large amounts of largely mechanical effort

* Contact
#bootstrappable and #guix on freenode
via bootstrappable.org
via our mailing list: bootstrappable@freelists.org
